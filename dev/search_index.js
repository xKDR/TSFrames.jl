var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = TSFrames","category":"page"},{"location":"api/#TSFrames-API-reference","page":"API reference","title":"TSFrames API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"API reference of TSFrames.","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [TSFrames]","category":"page"},{"location":"api/#Base.Matrix-Tuple{TSFrame}","page":"API reference","title":"Base.Matrix","text":"Conversion of non-Index data to Matrix\n\nData in non-index columns of a TSFrame object can be converted into a Matrix type for further numerical analysis using the Matrix() constructor.\n\nExamples\n\njulia> using Random;\njulia> random(x) = rand(MersenneTwister(123), x);\njulia> ts = TSFrame([random(10) random(10)])\njulia> show(ts)\n(10 x 2) TSFrame with Int64 Index\n\n Index  x1         x2\n Int64  Float64    Float64\n─────────────────────────────\n     1  0.768448   0.768448\n     2  0.940515   0.940515\n     3  0.673959   0.673959\n     4  0.395453   0.395453\n     5  0.313244   0.313244\n     6  0.662555   0.662555\n     7  0.586022   0.586022\n     8  0.0521332  0.0521332\n     9  0.26864    0.26864\n    10  0.108871   0.108871\n\njulia> Matrix(ts)\n10×2 Matrix{Float64}:\n 0.768448   0.768448\n 0.940515   0.940515\n 0.673959   0.673959\n 0.395453   0.395453\n 0.313244   0.313244\n 0.662555   0.662555\n 0.586022   0.586022\n 0.0521332  0.0521332\n 0.26864    0.26864\n 0.108871   0.108871\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.TSFrame","page":"API reference","title":"TSFrames.TSFrame","text":"struct TSFrame\n  coredata :: DataFrame\nend\n\n::TSFrame - A type to hold ordered data with an index.\n\nA TSFrame object is essentially a DataFrame with a specific column marked as an index. The input DataFrame is sorted during construction and is stored under the property coredata. The index is stored in the Index column of coredata.\n\nPermitted data inputs to the constructors are DataFrame, Vector, and 2-dimensional Array. If an index is already not present in the constructor then a sequential integer index is created automatically.\n\nTSFrame(coredata::DataFrame): Here, the constructor looks for a column named Index in coredata as the index column, if this is not found then the first column of coredata is made the index by default. If coredata only has a single column then a new sequential index is generated.\n\nSince TSFrame.coredata is a DataFrame it can be operated upon independently using methods provided by the DataFrames package (ex. transform, combine, etc.).\n\nConstructors\n\nTSFrame(coredata::DataFrame, index::Union{String, Symbol, Int})\nTSFrame(coredata::DataFrame, index::AbstractVector{T}) where {T<:Union{Int, TimeType}}\nTSFrame(coredata::DataFrame)\nTSFrame(coredata::DataFrame, index::UnitRange{Int})\nTSFrame(coredata::AbstractVector{T}, index::AbstractVector{V}; colnames=:auto) where {T, V}\nTSFrame(coredata::AbstractVector{T}; colnames=:auto) where {T}\nTSFrame(coredata::AbstractArray{T,2}; colnames=:auto) where {T}\nTSFrame(coredata::AbstractArray{T,2}, index::AbstractVector{V}; colnames=:auto) where {T, V}\nTSFrame(IndexType::DataType; n::Int=1)\nTSFrame(IndexType::DataType, cols::Vector{Tuple{DataType, S}}) where S <: Union{Symbol, String}\n\nExamples\n\njulia> using Random;\njulia> random(x) = rand(MersenneTwister(123), x);\n\njulia> df = DataFrame(x1 = random(10))\n10×1 DataFrame\n Row │ x1\n     │ Float64\n─────┼───────────\n   1 │ 0.768448\n   2 │ 0.940515\n   3 │ 0.673959\n   4 │ 0.395453\n   5 │ 0.313244\n   6 │ 0.662555\n   7 │ 0.586022\n   8 │ 0.0521332\n   9 │ 0.26864\n  10 │ 0.108871\n\njulia> ts = TSFrame(df)   # generates index\n(10 x 1) TSFrame with Int64 Index\n\n Index  x1\n Int64  Float64\n──────────────────\n     1  0.768448\n     2  0.940515\n     3  0.673959\n     4  0.395453\n     5  0.313244\n     6  0.662555\n     7  0.586022\n     8  0.0521332\n     9  0.26864\n    10  0.108871\n\n# ts.coredata is a DataFrame\njulia> combine(ts.coredata, :x1 => Statistics.mean, DataFrames.nrow)\n1×2 DataFrame\n Row │ x1_mean  nrow\n     │ Float64  Int64\n─────┼────────────────\n   1 │ 0.49898    418\n\njulia> df = DataFrame(ind = [1, 2, 3], x1 = random(3))\n3×2 DataFrame\n Row │ ind    x1\n     │ Int64  Float64\n─────┼─────────────────\n   1 │     1  0.768448\n   2 │     2  0.940515\n   3 │     3  0.673959\n\njulia> ts = TSFrame(df, 1)        # the first column is index\n(3 x 1) TSFrame with Int64 Index\n\n Index  x1\n Int64  Float64\n─────────────────\n     1  0.768448\n     2  0.940515\n     3  0.673959\n\njulia> df = DataFrame(x1 = random(3), x2 = random(3), Index = [1, 2, 3]);\n3×3 DataFrame\n Row │ x1        x2        Index\n     │ Float64   Float64   Int64\n─────┼───────────────────────────\n   1 │ 0.768448  0.768448      1\n   2 │ 0.940515  0.940515      2\n   3 │ 0.673959  0.673959      3\n\njulia> ts = TSFrame(df)   # uses existing `Index` column\n(3 x 2) TSFrame with Int64 Index\n\n Index  x1        x2\n Int64  Float64   Float64\n───────────────────────────\n     1  0.768448  0.768448\n     2  0.940515  0.940515\n     3  0.673959  0.673959\n\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10));\n\njulia> df = DataFrame(dates = dates, x1 = random(10))\n10×2 DataFrame\n Row │ dates       x1\n     │ Date        Float64\n─────┼───────────────────────\n   1 │ 2017-01-01  0.768448\n   2 │ 2017-01-02  0.940515\n   3 │ 2017-01-03  0.673959\n   4 │ 2017-01-04  0.395453\n   5 │ 2017-01-05  0.313244\n   6 │ 2017-01-06  0.662555\n   7 │ 2017-01-07  0.586022\n   8 │ 2017-01-08  0.0521332\n   9 │ 2017-01-09  0.26864\n  10 │ 2017-01-10  0.108871\n\njulia> ts = TSFrame(df, :dates)\n(10 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n 2017-01-09  0.26864\n 2017-01-10  0.108871\n\njulia> ts = TSFrame(DataFrame(x1=random(10)), dates);\n\njulia> ts = TSFrame(random(10))\n(10 x 1) TSFrame with Int64 Index\n\n Index  x1\n Int64  Float64\n──────────────────\n     1  0.768448\n     2  0.940515\n     3  0.673959\n     4  0.395453\n     5  0.313244\n     6  0.662555\n     7  0.586022\n     8  0.0521332\n     9  0.26864\n    10  0.108871\n\njulia> ts = TSFrame(random(10), colnames=[:A]) # column is named A\n(10 x 1) TSFrame with Int64 Index\n\n Index  A\n Int64  Float64\n──────────────────\n     1  0.768448\n     2  0.940515\n     3  0.673959\n     4  0.395453\n     5  0.313244\n     6  0.662555\n     7  0.586022\n     8  0.0521332\n     9  0.26864\n    10  0.108871\n\njulia> ts = TSFrame(random(10), dates)\n(10 x 1) TSFrame with Date Index\n\n Index       x1        \n Date        Float64   \n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n 2017-01-09  0.26864\n 2017-01-10  0.108871\n\njulia> ts = TSFrame(random(10), dates, colnames=[:A]) # column is named A\n(10 x 1) TSFrame with Date Index\n\n Index       A         \n Date        Float64   \n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n 2017-01-09  0.26864\n 2017-01-10  0.108871\n\njulia> ts = TSFrame([random(10) random(10)]) # matrix object\n(10 x 2) TSFrame with Int64 Index\n\n Index  x1         x2        \n Int64  Float64    Float64   \n─────────────────────────────\n     1  0.768448   0.768448\n     2  0.940515   0.940515\n     3  0.673959   0.673959\n     4  0.395453   0.395453\n     5  0.313244   0.313244\n     6  0.662555   0.662555\n     7  0.586022   0.586022\n     8  0.0521332  0.0521332\n     9  0.26864    0.26864\n    10  0.108871   0.108871\n\njulia> ts = TSFrame([random(10) random(10)], colnames=[:A, :B]) # columns are named A and B\n(10 x 2) TSFrame with Int64 Index\n\n Index  A          B       \n Int64  Float64    Float64   \n─────────────────────────────\n     1  0.768448   0.768448\n     2  0.940515   0.940515\n     3  0.673959   0.673959\n     4  0.395453   0.395453\n     5  0.313244   0.313244\n     6  0.662555   0.662555\n     7  0.586022   0.586022\n     8  0.0521332  0.0521332\n     9  0.26864    0.26864\n    10  0.108871   0.108871\n\njulia> ts = TSFrame([random(10) random(10)], dates) \n(10 x 2) TSFrame with Date Index\n\n Index       x1         x2\n Date        Float64    Float64\n──────────────────────────────────\n 2017-01-01  0.768448   0.768448\n 2017-01-02  0.940515   0.940515\n 2017-01-03  0.673959   0.673959\n 2017-01-04  0.395453   0.395453\n 2017-01-05  0.313244   0.313244\n 2017-01-06  0.662555   0.662555\n 2017-01-07  0.586022   0.586022\n 2017-01-08  0.0521332  0.0521332\n 2017-01-09  0.26864    0.26864\n 2017-01-10  0.108871   0.108871\n\njulia> ts = TSFrame([random(10) random(10)], dates, colnames=[:A, :B]) # columns are named A and B\n(10 x 2) TSFrame with Date Index\n\n Index       A          B         \n Date        Float64    Float64   \n──────────────────────────────────\n 2017-01-01  0.768448   0.768448\n 2017-01-02  0.940515   0.940515\n 2017-01-03  0.673959   0.673959\n 2017-01-04  0.395453   0.395453\n 2017-01-05  0.313244   0.313244\n 2017-01-06  0.662555   0.662555\n 2017-01-07  0.586022   0.586022\n 2017-01-08  0.0521332  0.0521332\n 2017-01-09  0.26864    0.26864\n 2017-01-10  0.108871   0.108871\n\njulia> ts = TSFrame(Int64; n=5) # empty TSFrame with 5 columns of type Any and with Int64 index type\n0×5 TSFrame with Int64 Index\n\njulia> ts = TSFrame(Date, [(Int64, :col1), (String, :col2), (Float64, :col3)]) # empty TSFrame with specific column names and types\n0×3 TSFrame with Date Index\n\njulia> ts = TSFrame(Date, [(Int64, \"col1\"), (String, \"col2\"), (Float64, \"col3\")]) # using strings instead of symbols\n0×3 TSFrame with Date Index\n\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:==-Tuple{TSFrame, TSFrame}","page":"API reference","title":"Base.:==","text":"Equality\n\nTwo TSFrame are considered equal if their `coredata` property is equal.\nBase.:(==)(tsf1::TSFrame, tsf2::TSFrame)::Bool\nBase.isequal(tsf1::TSFrame, tsf2::TSFrame)::Bool\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.first-Tuple{TSFrame}","page":"API reference","title":"Base.first","text":"First Row\n\nfirst(ts::TSFrame)\n\nReturns the first row of ts as a TSFrame object.\n\nExamples\n\njulia> first(TSFrame(1:10))\n(10 x 1) TSFrame with Dates.Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2022-02-01  0.768448\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate","page":"API reference","title":"Base.iterate","text":"Iterators\n\nBase.iterate(tsf::TSFrame)\n\nReturns a row-based iterator for `tsf`.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.join-Tuple{TSFrame, TSFrame, Vararg{Any}}","page":"API reference","title":"Base.join","text":"Joins/Column-binding\n\njoin(ts1::TSFrame, ts2::TSFrame, ts...; jointype::Symbol=:JoinAll)\n\nTSFrame objects can be combined together column-wise using Index as the column key. There are four kinds of column-binding operations possible as of now. Each join operation works by performing a Set operation on the Index column and then merging the datasets based on the output from the Set operation. Each operation changes column names in the final object automatically if the operation encounters duplicate column names amongst the TSFrame objects.\n\nThe following join types are supported:\n\njoin(ts1::TSFrame, ts2::TSFrame; jointype=:JoinInner) and join(ts1::TSFrame, ts2::TSFrame; jointype=:JoinBoth)\n\na.k.a. inner join, takes the intersection of the indexes of ts1 and ts2, and then merges the columns of both the objects. The resulting object will only contain rows which are present in both the objects' indexes. The function will rename columns in the final object if they had same names in the TSFrame objects.\n\njoin(ts1::TSFrame, ts2::TSFrame; jointype=:JoinOuter) and join(ts1::TSFrame, ts2::TSFrame; jointype=:JoinAll):\n\na.k.a. outer join, takes the union of the indexes of ts1 and ts2 before merging the other columns of input objects. The output will contain rows which are present in all the input objects while inserting missing values where a row was not present in any of the objects. This is the default behaviour if no jointype is provided.\n\njoin(ts1::TSFrame, ts2::TSFrame; jointype=:JoinLeft):\n\nLeft join takes the index values which are present in the left object ts1 and finds matching index values in the right object ts2. The resulting object includes all the rows from the left object, the column values from the left object, and the values associated with matching index rows on the right. The operation inserts missing values where in the unmatched rows of the right object.\n\njoin(ts1::TSFrame, ts2::TSFrame; jointype=:JoinRight)\n\nRight join, similar to left join but works in the opposite direction. The final object contains all the rows from the right object while inserting missing values in rows missing from the left object.\n\nThe default behaviour is to assume jointype=:JoinAll if no jointype is provided to the join method.\n\nJoining multiple TSFrames is also supported. The syntax is\n\njoin(ts1::TSFrame, ts2::TSFrame, ts...; jointype::Symbol)\n\nwhere jointype must be one of :JoinInner, :JoinBoth, :JoinOuter, :JoinAll, :JoinLeft or :JoinRight. Note that join on multiple TSFrames is left associative.\n\ncbind is an alias for join method.\n\nExamples\n\njulia> using Random;\n\njulia> random(x) = rand(MersenneTwister(123), x);\n\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10));\n\njulia> ts1 = TSFrame(random(length(dates)), dates);\njulia> show(ts1)\n(10 x 1) TSFrame with Dates.Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n 2017-01-09  0.26864\n 2017-01-10  0.108871\n\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2017,1,30));\n\njulia> ts2 = TSFrame(random(length(dates)), dates);\njulia> show(ts2)\n30×1 TSFrame with Date Index\n Index       x1\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n 2017-01-09  0.26864\n 2017-01-10  0.108871\n 2017-01-11  0.163666\n 2017-01-12  0.473017\n 2017-01-13  0.865412\n 2017-01-14  0.617492\n 2017-01-15  0.285698\n 2017-01-16  0.463847\n 2017-01-17  0.275819\n 2017-01-18  0.446568\n 2017-01-19  0.582318\n 2017-01-20  0.255981\n 2017-01-21  0.70586\n 2017-01-22  0.291978\n 2017-01-23  0.281066\n 2017-01-24  0.792931\n 2017-01-25  0.20923\n 2017-01-26  0.918165\n 2017-01-27  0.614255\n 2017-01-28  0.802665\n 2017-01-29  0.555668\n 2017-01-30  0.940782\n\n# join on all index values\n# equivalent to `join(ts1, ts2; jointype=:JoinAll)` call\njulia> join(ts1, ts2)\n(30 x 2) TSFrame with Date Index\n Index       x1               x1_1\n Date        Float64?         Float64?\n────────────────────────────────────────\n 2017-01-01        0.768448   0.768448\n 2017-01-02        0.940515   0.940515\n 2017-01-03        0.673959   0.673959\n 2017-01-04        0.395453   0.395453\n 2017-01-05        0.313244   0.313244\n 2017-01-06        0.662555   0.662555\n 2017-01-07        0.586022   0.586022\n 2017-01-08        0.0521332  0.0521332\n 2017-01-09        0.26864    0.26864\n 2017-01-10        0.108871   0.108871\n     ⋮              ⋮             ⋮\n 2017-01-22  missing          0.291978\n 2017-01-23  missing          0.281066\n 2017-01-24  missing          0.792931\n 2017-01-25  missing          0.20923\n 2017-01-26  missing          0.918165\n 2017-01-27  missing          0.614255\n 2017-01-28  missing          0.802665\n 2017-01-29  missing          0.555668\n 2017-01-30  missing          0.940782\n                         11 rows omitted\n\n# alias to `join()`\njulia> cbind(ts1, ts2);\n\n# join only the common index values\njulia> join(ts1, ts2; jointype=:JoinBoth)\n(10 x 2) TSFrame with Date Index\n Index       x1         x1_1\n Date        Float64    Float64\n──────────────────────────────────\n 2017-01-01  0.768448   0.768448\n 2017-01-02  0.940515   0.940515\n 2017-01-03  0.673959   0.673959\n 2017-01-04  0.395453   0.395453\n 2017-01-05  0.313244   0.313244\n 2017-01-06  0.662555   0.662555\n 2017-01-07  0.586022   0.586022\n 2017-01-08  0.0521332  0.0521332\n 2017-01-09  0.26864    0.26864\n 2017-01-10  0.108871   0.108871\n\n# keep index values of `ts1`\njulia> join(ts1, ts2; jointype=:JoinLeft)\n(10 x 2) TSFrame with Date Index\n Index       x1         x1_1\n Date        Float64    Float64?\n──────────────────────────────────\n 2017-01-01  0.768448   0.768448\n 2017-01-02  0.940515   0.940515\n 2017-01-03  0.673959   0.673959\n 2017-01-04  0.395453   0.395453\n 2017-01-05  0.313244   0.313244\n 2017-01-06  0.662555   0.662555\n 2017-01-07  0.586022   0.586022\n 2017-01-08  0.0521332  0.0521332\n 2017-01-09  0.26864    0.26864\n 2017-01-10  0.108871   0.108871\n\n# keep index values of `ts2`\njulia> join(ts1, ts2; jointype=:JoinRight)\n(30 x 2) TSFrame with Date Index\n Index       x1               x1_1\n Date        Float64?         Float64\n────────────────────────────────────────\n 2017-01-01        0.768448   0.768448\n 2017-01-02        0.940515   0.940515\n 2017-01-03        0.673959   0.673959\n 2017-01-04        0.395453   0.395453\n 2017-01-05        0.313244   0.313244\n 2017-01-06        0.662555   0.662555\n 2017-01-07        0.586022   0.586022\n 2017-01-08        0.0521332  0.0521332\n 2017-01-09        0.26864    0.26864\n 2017-01-10        0.108871   0.108871\n     ⋮              ⋮             ⋮\n 2017-01-22  missing          0.291978\n 2017-01-23  missing          0.281066\n 2017-01-24  missing          0.792931\n 2017-01-25  missing          0.20923\n 2017-01-26  missing          0.918165\n 2017-01-27  missing          0.614255\n 2017-01-28  missing          0.802665\n 2017-01-29  missing          0.555668\n 2017-01-30  missing          0.940782\n                         11 rows omitted\n\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2017,1,30));\n\njulia> ts3 = TSFrame(random(length(dates)), dates);\njulia> show(ts3)\n30×1 TSFrame with Date Index\n Index       x1\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n 2017-01-09  0.26864\n 2017-01-10  0.108871\n 2017-01-11  0.163666\n 2017-01-12  0.473017\n 2017-01-13  0.865412\n 2017-01-14  0.617492\n 2017-01-15  0.285698\n 2017-01-16  0.463847\n 2017-01-17  0.275819\n 2017-01-18  0.446568\n 2017-01-19  0.582318\n 2017-01-20  0.255981\n 2017-01-21  0.70586\n 2017-01-22  0.291978\n 2017-01-23  0.281066\n 2017-01-24  0.792931\n 2017-01-25  0.20923\n 2017-01-26  0.918165\n 2017-01-27  0.614255\n 2017-01-28  0.802665\n 2017-01-29  0.555668\n 2017-01-30  0.940782\n\n# joining multiple TSFrame objects\njulia> join(ts1, ts2, ts3; jointype=:JoinLeft)\n10×3 TSFrame with Date Index\n Index       x1         x1_1       x1_2\n Date        Float64    Float64?   Float64?\n─────────────────────────────────────────────\n 2017-01-01  0.768448   0.768448   0.768448\n 2017-01-02  0.940515   0.940515   0.940515\n 2017-01-03  0.673959   0.673959   0.673959\n 2017-01-04  0.395453   0.395453   0.395453\n 2017-01-05  0.313244   0.313244   0.313244\n 2017-01-06  0.662555   0.662555   0.662555\n 2017-01-07  0.586022   0.586022   0.586022\n 2017-01-08  0.0521332  0.0521332  0.0521332\n 2017-01-09  0.26864    0.26864    0.26864\n 2017-01-10  0.108871   0.108871   0.108871\n\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{TSFrame}","page":"API reference","title":"Base.size","text":"Size methods\n\nsize(ts::TSFrame)\n\nReturn the number of rows and columns of ts as a tuple.\n\nExamples\n\njulia> TSFrames.size(TSFrame([collect(1:100) collect(1:100) collect(1:100)]))\n(100, 3)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.vcat-Tuple{TSFrame, TSFrame}","page":"API reference","title":"Base.vcat","text":"Row-merging (vcat/rbind)\n\nvcat(ts1::TSFrame, ts2::TSFrame; colmerge::Symbol=:union)\n\nConcatenate rows of two TSFrame objects, append ts2 to ts1.\n\nThe colmerge keyword argument specifies the column merge strategy. The value of colmerge is directly passed to cols argument of DataFrames.vcat.\n\nCurrently, DataFrames.vcat supports four types of column-merge strategies:\n\n:setequal: only merge if both objects have same column names, use the order of columns in ts1.\n:orderequal: only merge if both objects have same column names and columns are in the same order.\n:intersect: only merge the columns which are common to both objects, ignore the rest.\n:union: merge even if columns differ, the resulting object has all the columns filled with missing, if necessary.\n\nExamples\n\njulia> using Random;\n\njulia> random(x) = rand(MersenneTwister(123), x);\n\njulia> dates1 = collect(Date(2017,1,1):Day(1):Date(2017,1,10));\n\njulia> dates2 = collect(Date(2017,1,11):Day(1):Date(2017,1,30));\n\njulia> ts1 = TSFrame([randn(length(dates1)) randn(length(dates1))], dates1)\njulia> show(ts1)\n(10 x 1) TSFrame with Dates.Date Index\n\n Index       x1\n Date        Float64\n────────────────────────\n 2017-01-01  -0.420348\n 2017-01-02   0.109363\n 2017-01-03  -0.0702014\n 2017-01-04   0.165618\n 2017-01-05  -0.0556799\n 2017-01-06  -0.147801\n 2017-01-07  -2.50723\n 2017-01-08  -0.099783\n 2017-01-09   0.177526\n 2017-01-10  -1.08461\n\njulia> df = DataFrame(x1 = randn(length(dates2)), y1 = randn(length(dates2)))\njulia> ts2 = TSFrame(df, dates2)\njulia> show(ts2)\n(20 x 1) TSFrame with Dates.Date Index\n\n Index       x1\n Date        Float64\n────────────────────────\n 2017-01-11   2.15087\n 2017-01-12   0.9203\n 2017-01-13  -0.0879142\n 2017-01-14  -0.930109\n 2017-01-15   0.061117\n 2017-01-16   0.0434627\n 2017-01-17   0.0834733\n 2017-01-18  -1.52281\n     ⋮           ⋮\n 2017-01-23  -0.756143\n 2017-01-24   0.491623\n 2017-01-25   0.549672\n 2017-01-26   0.570689\n 2017-01-27  -0.380011\n 2017-01-28  -2.09965\n 2017-01-29   1.37289\n 2017-01-30  -0.462384\n          4 rows omitted\n\n\njulia> vcat(ts1, ts2)\n(30 x 3) TSFrame with Date Index\n\n Index       x1          x2              y1\n Date        Float64     Float64?        Float64?\n─────────────────────────────────────────────────────────\n 2017-01-01  -0.524798        -1.4949    missing\n 2017-01-02  -0.719611        -1.1278    missing\n 2017-01-03   0.0926092        1.19778   missing\n 2017-01-04   0.236237         1.39115   missing\n 2017-01-05   0.369588         1.21792   missing\n 2017-01-06   1.65287         -0.930058  missing\n 2017-01-07   0.761301         0.23794   missing\n 2017-01-08  -0.571046        -0.480486  missing\n 2017-01-09  -2.01905         -0.46391   missing\n 2017-01-10   0.193942        -1.01471   missing\n 2017-01-11   0.239041   missing              -0.473429\n 2017-01-12   0.286036   missing              -0.90377\n 2017-01-13   0.683429   missing              -0.128489\n 2017-01-14  -1.51442    missing              -2.39843\n 2017-01-15  -0.581341   missing              -0.12265\n 2017-01-16   1.07059    missing              -0.916064\n 2017-01-17   0.859396   missing               0.0162969\n 2017-01-18  -1.93127    missing               2.11127\n 2017-01-19   0.529477   missing               0.636964\n 2017-01-20   0.817429   missing              -0.34038\n 2017-01-21  -0.682296   missing              -0.971262\n 2017-01-22   1.36232    missing              -0.236323\n 2017-01-23   0.143188   missing              -0.501722\n 2017-01-24   0.621845   missing              -1.20016\n 2017-01-25   0.076199   missing              -1.36616\n 2017-01-26   0.379672   missing              -0.555395\n 2017-01-27   0.494473   missing               1.05389\n 2017-01-28   0.278259   missing              -0.358983\n 2017-01-29   0.0231765  missing               0.712526\n 2017-01-30   0.516704   missing               0.216855\n\njulia> vcat(ts1, ts2; colmerge=:intersect)\n(30 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64\n────────────────────────\n 2017-01-01  -0.524798\n 2017-01-02  -0.719611\n 2017-01-03   0.0926092\n 2017-01-04   0.236237\n 2017-01-05   0.369588\n 2017-01-06   1.65287\n 2017-01-07   0.761301\n 2017-01-08  -0.571046\n 2017-01-09  -2.01905\n 2017-01-10   0.193942\n 2017-01-11   0.239041\n 2017-01-12   0.286036\n 2017-01-13   0.683429\n 2017-01-14  -1.51442\n 2017-01-15  -0.581341\n 2017-01-16   1.07059\n 2017-01-17   0.859396\n 2017-01-18  -1.93127\n 2017-01-19   0.529477\n 2017-01-20   0.817429\n 2017-01-21  -0.682296\n 2017-01-22   1.36232\n 2017-01-23   0.143188\n 2017-01-24   0.621845\n 2017-01-25   0.076199\n 2017-01-26   0.379672\n 2017-01-27   0.494473\n 2017-01-28   0.278259\n 2017-01-29   0.0231765\n 2017-01-30   0.516704\n\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe","page":"API reference","title":"RecipesBase.apply_recipe","text":"Plotting\n\nplot(ts::TSFrame, cols::Vector{Int} = collect(1:TSFrames.ncol(ts)))\nplot(ts::TSFrame, cols::Vector{T}) where {T<:Union{String, Symbol}}\nplot(ts::TSFrame, cols::T) where {T<:Union{Int, String, Symbol}}\n\nPlots a TSFrame object with the index on the x-axis and selected cols on the y-axis. By default, plot all the columns. Columns can be selected using Int indexes, String(s), or Symbol(s).\n\nExample\n\njulia> using Random;\njulia> random(x) = rand(MersenneTwister(123), x);\njulia> dates = Date(\"2022-01-01\"):Month(1):Date(\"2022-01-01\")+Month(11);\n\njulia> df = DataFrame(Index = dates,\n        val1 = random(12),\n        val2 = random(12),\n        val3 = random(12));\n\njulia> ts = TSFrame(df)\njulia> show(ts)\n(12 x 3) TSFrame with Dates.Date Index\n\n Index       val1        val2        val3\n Date        Float64     Float64     Float64\n────────────────────────────────────────────────\n 2022-01-01  -0.319954    0.974594   -0.552977\n 2022-02-01  -0.0386735  -0.171675    0.779539\n 2022-03-01   1.67678    -1.75251     0.820462\n 2022-04-01   1.69702    -0.0130037   1.0507\n 2022-05-01   0.992128    0.76957    -1.28008\n 2022-06-01  -0.315461   -0.543976   -0.117256\n 2022-07-01  -1.18952    -1.12867    -0.0829082\n 2022-08-01   0.159595    0.450044   -0.231828\n 2022-09-01   0.501436    0.265327   -0.948532\n 2022-10-01  -2.10516    -1.11489     0.285194\n 2022-11-01  -0.781082   -1.20202    -0.639953\n 2022-12-01  -0.169184    1.34879     1.33361\n\n\njulia> using Plots\n\njulia> # plot(ts)\n\n# plot first 6 rows with selected columns\njulia> # plot(ts[1:6], [:val1, :val3]);\n\n# plot columns 1 and 2 on a specified window size\njulia> # plot(ts, [1, 2], size=(600, 400));\n\n\n\n\n\n","category":"function"},{"location":"api/#TSFrames._check_consistency-Tuple{TSFrame}","page":"API reference","title":"TSFrames._check_consistency","text":"Internal function to check consistency of the Index of a TSFrame object.\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.apply-Union{Tuple{V}, Tuple{T}, Tuple{TSFrame, T, V}, Tuple{TSFrame, T, V, Function}} where {T<:Dates.Period, V<:Function}","page":"API reference","title":"TSFrames.apply","text":"Apply/Period conversion\n\napply(ts::TSFrame,\n      period::T,\n      fun::V,\n      index_at::Function=first;\n      renamecols::Bool=true)\n     where {T<:Dates.Period, V <: Function}\n\nApply fun to ts object based on period and return correctly indexed rows. This method is used for doing aggregation over a time period or to convert ts into an object of lower frequency (ex. from daily series to monthly).\n\nperiod is any of Period types in the Dates module. Conversion from lower to a higher frequency will throw an error as interpolation isn't currently handled by this method.\n\nBy default, the method uses the first value of the index within the period to index the resulting aggregated object. This behaviour can be controlled by index_at argument which can take first or last as an input.\n\nKeyword arguments\n\nrenamecols::Bool=true: whether to rename column names in the  resulting object. If false, the column name is automatically  generated based on the name of fun otherwise existing column  names are used.\n\nExamples\n\njulia> using Random, Statistics;\njulia> random(x) = rand(MersenneTwister(123), x);\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2018,3,10));\n\njulia> ts = TSFrame(random(length(dates)), dates)\njulia> show(ts[1:10])\n(10 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n 2017-01-09  0.26864\n 2017-01-10  0.108871\n\njulia> apply(ts, Month(1), first)\n(15 x 1) TSFrame with Date Index\n\n Index       x1_first\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-02-01  0.790201\n 2017-03-01  0.467219\n 2017-04-01  0.783473\n 2017-05-01  0.651354\n 2017-06-01  0.373346\n 2017-07-01  0.83296\n 2017-08-01  0.132716\n 2017-09-01  0.27899\n 2017-10-01  0.995414\n 2017-11-01  0.214132\n 2017-12-01  0.832917\n 2018-01-01  0.0409471\n 2018-02-01  0.720163\n 2018-03-01  0.87459\n\n# alternate months\njulia> apply(ts, Month(2), first)\n(8 x 1) TSFrame with Date Index\n\n Index       x1_first\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-03-01  0.467219\n 2017-05-01  0.651354\n 2017-07-01  0.83296\n 2017-09-01  0.27899\n 2017-11-01  0.214132\n 2018-01-01  0.0409471\n 2018-03-01  0.87459\n\n\njulia> ts_weekly = apply(ts, Week(1), Statistics.std) # weekly standard deviation\njulia> show(ts_weekly[1:10])\n(10 x 1) TSFrame with Date Index\n\n Index       x1_std\n Date        Float64\n────────────────────────\n 2017-01-01  NaN\n 2017-01-02    0.28935\n 2017-01-09    0.270842\n 2017-01-16    0.170197\n 2017-01-23    0.269573\n 2017-01-30    0.326687\n 2017-02-06    0.279935\n 2017-02-13    0.319216\n 2017-02-20    0.272058\n 2017-02-27    0.23651\n\n\njulia> ts_weekly = apply(ts, Week(1), Statistics.std, last) # indexed by last date of the week\njulia> show(ts_weekly[1:10])\n(10 x 1) TSFrame with Date Index\n\n Index       x1_std\n Date        Float64\n────────────────────────\n 2017-01-01  NaN\n 2017-01-08    0.28935\n 2017-01-15    0.270842\n 2017-01-22    0.170197\n 2017-01-29    0.269573\n 2017-02-05    0.326687\n 2017-02-12    0.279935\n 2017-02-19    0.319216\n 2017-02-26    0.272058\n 2017-03-05    0.23651\n\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.describe-Tuple{IO, TSFrame}","page":"API reference","title":"TSFrames.describe","text":"Summary statistics\n\ndescribe(ts::TSFrame; cols=:)\ndescribe(ts::TSFrame, stats::Union{Symbol, Pair}...; cols=:)\n\nCompute summary statistics of ts. The output is a DataFrame containing standard statistics along with number of missing values and data types of columns. The cols keyword controls which subset of columns from ts to be selected. The stats keyword is used to control which summary statistics are to be printed. For more information about these keywords, check out the corresponding documentation from DataFrames.jl.\n\nExamples\n\njulia> using Random;\njulia> random(x) = rand(MersenneTwister(123), x...);\njulia> ts = TSFrame(random(([1, 2, 3, 4, missing], 10)))\njulia> describe(ts)\n2×7 DataFrame\n Row │ variable  mean     min    median   max    nmissing  eltype\n     │ Symbol    Float64  Int64  Float64  Int64  Int64     Type\n─────┼───────────────────────────────────────────────────────────────────────────\n   1 │ Index        5.5       1      5.5     10         0  Int64\n   2 │ x1           2.75      2      3.0      4         2  Union{Missing, Int64}\njulia> describe(ts, cols=:Index)\n1×7 DataFrame\n Row │ variable  mean     min    median   max    nmissing  eltype\n     │ Symbol    Float64  Int64  Float64  Int64  Int64     DataType\n─────┼──────────────────────────────────────────────────────────────\n   1 │ Index         5.5      1      5.5     10         0  Int64\njulia> describe(ts, :min, :max, cols=:x1)\n1×3 DataFrame\n Row │ variable  min    max\n     │ Symbol    Int64  Int64\n─────┼────────────────────────\n   1 │ x1            2      4\njulia> describe(ts, :min, sum => :sum)\n2×3 DataFrame\n Row │ variable  min    sum\n     │ Symbol    Int64  Int64\n─────┼────────────────────────\n   1 │ Index         1     55\n   2 │ x1            2     22\njulia> describe(ts, :min, sum => :sum, cols=:x1)\n1×3 DataFrame\n Row │ variable  min    sum\n     │ Symbol    Int64  Int64\n─────┼────────────────────────\n   1 │ x1            2     22\n\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.endpoints","page":"API reference","title":"TSFrames.endpoints","text":"Computing end points\n\nendpoints(timestamps::AbstractVector{T}, on::V) where {T<:Union{Date, DateTime, Time},\n                                                       V<:Union{\n                                                           Year,\n                                                           Quarter,\n                                                           Month,\n                                                           Week,\n                                                           Day,\n                                                           Hour,\n                                                           Minute,\n                                                           Second,\n                                                           Millisecond,\n                                                           Microsecond,\n                                                           Nanosecond\n                                                       }}\nendpoints(ts::TSFrame, on::T) where {T<:Dates.Period}\nendpoints(ts::TSFrame, on::Symbol, k::Int=1)\nendpoints(ts::TSFrame, on::String, k::Int=1)\nendpoints(ts::TSFrame, on::Function, k::Int=1)\nendpoints(values::AbstractVector, on::Function, k::Int=1)\n\nReturn an integer vector of values for last observation in timestamps for each period given by on. The values are picked up every on.value instance of the period.\n\nCan be used to subset a TSFrame object directly using this function's return value. The methods work for regular time series of any periodicity and irregular time series belonging to any of the time-based types provided by the Dates module.\n\nThe primary method works for series of all time types including Date, DateTime, and Time, and for on belonging to any of the sub-types of Dates.Period. The ::TSFrame methods are provided for convenience and call the primary method directly using the Index column.\n\nFor the methods accepting on of Function type the values vector will get converted into unique period-groups which act as unique keys. The method uses these keys to create groups of values and uses the period provided by on to pick up the last observation in each group. k decides the number of groups to skip. For example, k=2 picks every alternate group starting from the 2ⁿᵈ element out of the ones created by on. See the examples below to see how the function works in the real world. The on function should return a Vector to be used as grouping keys.\n\nendpoints(ts::TSFrame, on::Symbol) and endpoints(ts::TSFrame, on::String) are convenience methods where valid values for on are: :years, :quarters, :months, :weeks, :days, :hours, :minutes, :seconds, :milliseconds, :microseconds, and :nanoseconds.\n\nNote, that except for on::Function all other methods expect Index type of TSFrame to be a subtype of TimeType.\n\nThe method returns Vector{Int} corresponding to the matched values in the first argument.\n\nExamples\n\njulia> using Random\njulia> random(x) = rand(MersenneTwister(123), x);\njulia> dates = Date(2017):Day(1):Date(2019);\njulia> ts = TSFrame(random(length(dates)), dates)\n(731 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n 2017-01-09  0.26864\n 2017-01-10  0.108871\n     ⋮           ⋮\n 2018-12-24  0.812797\n 2018-12-25  0.158056\n 2018-12-26  0.269285\n 2018-12-27  0.15065\n 2018-12-28  0.916177\n 2018-12-29  0.278016\n 2018-12-30  0.617211\n 2018-12-31  0.67549\n 2019-01-01  0.910285\n       712 rows omitted\n\njulia> ep = endpoints(ts, Month(1))\n25-element Vector{Int64}:\n  31\n  59\n  90\n 120\n 151\n 181\n 212\n 243\n 273\n 304\n 334\n 365\n 396\n 424\n 455\n 485\n 516\n 546\n 577\n 608\n 638\n 669\n 699\n 730\n 731\n\njulia> ts[ep]\n(25 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2017-01-31  0.48\n 2017-02-28  0.458476\n 2017-03-31  0.274441\n 2017-04-30  0.413966\n 2017-05-31  0.734931\n 2017-06-30  0.257159\n 2017-07-31  0.415851\n 2017-08-31  0.0377973\n 2017-09-30  0.934059\n 2017-10-31  0.413175\n 2017-11-30  0.557009\n 2017-12-31  0.346659\n 2018-01-31  0.174777\n 2018-02-28  0.432223\n 2018-03-31  0.835142\n 2018-04-30  0.945539\n 2018-05-31  0.0635483\n 2018-06-30  0.589922\n 2018-07-31  0.285088\n 2018-08-31  0.912558\n 2018-09-30  0.238931\n 2018-10-31  0.49775\n 2018-11-30  0.830232\n 2018-12-31  0.67549\n 2019-01-01  0.910285\n\njulia> diff(index(ts[ep]))\n24-element Vector{Day}:\n 28 days\n 31 days\n 30 days\n 31 days\n 30 days\n 31 days\n 31 days\n 30 days\n 31 days\n 30 days\n 31 days\n 31 days\n 28 days\n 31 days\n 30 days\n 31 days\n 30 days\n 31 days\n 31 days\n 30 days\n 31 days\n 30 days\n 31 days\n 1 day\n\n# every 2ⁿᵈ month\njulia> ts[endpoints(ts, Month(2))]\n(12 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2017-02-28  0.458476\n 2017-04-30  0.413966\n 2017-06-30  0.257159\n 2017-08-31  0.0377973\n 2017-10-31  0.413175\n 2017-12-31  0.346659\n 2018-02-28  0.432223\n 2018-04-30  0.945539\n 2018-06-30  0.589922\n 2018-08-31  0.912558\n 2018-10-31  0.49775\n 2018-12-31  0.67549\n 2019-01-01  0.910285\n\n# Weekly points using a function\njulia> endpoints(ts, i -> lastdayofweek.(i), 1)\n106-element Vector{Int64}:\n   1\n   8\n  15\n  22\n  29\n  36\n  43\n   ⋮\n 694\n 701\n 708\n 715\n 722\n 729\n 731\n\njulia> endpoints(ts, i -> lastdayofweek.(i), 1) == endpoints(ts, Week(1))\ntrue\n\n# Time type series\njulia> timestampsminutes = collect(Time(9, 1, 2):Minute(1):Time(11, 2, 3));\njulia> timestampsminutes[endpoints(timestampsminutes, Minute(2))]\n61-element Vector{Time}:\n 09:02:02\n 09:04:02\n 09:06:02\n 09:08:02\n 09:10:02\n 09:12:02\n 09:14:02\n 09:16:02\n 09:18:02\n 09:20:02\n 09:22:02\n 09:24:02\n ⋮\n 10:40:02\n 10:42:02\n 10:44:02\n 10:46:02\n 10:48:02\n 10:50:02\n 10:52:02\n 10:54:02\n 10:56:02\n 10:58:02\n 11:00:02\n 11:02:02\n\njulia> timestampsminutes[endpoints(timestampsminutes, Hour(1))]\n3-element Vector{Time}:\n 09:59:02\n 10:59:02\n 11:02:02\n\n## Irregular series\njulia> datetimeseconds = collect(range(DateTime(2022, 10, 08) + Hour(9),\n                                DateTime(2022, 10, 08) + Hour(15) + Minute(29),\n                                step=Second(1)));\njulia> datetimesecondsrandom = sample(MersenneTwister(123), datetimeseconds, 20, replace=false, ordered=true)\n17-element Vector{DateTime}:\n 2022-10-08T09:20:16\n 2022-10-08T09:32:00\n 2022-10-08T09:43:57\n 2022-10-08T10:13:27\n 2022-10-08T10:44:34\n 2022-10-08T11:04:23\n 2022-10-08T11:08:37\n 2022-10-08T11:46:51\n 2022-10-08T11:56:46\n 2022-10-08T12:14:22\n 2022-10-08T12:32:08\n 2022-10-08T13:28:42\n 2022-10-08T13:34:33\n 2022-10-08T13:54:11\n 2022-10-08T13:59:08\n 2022-10-08T14:05:57\n 2022-10-08T14:37:17\n\njulia> datetimesecondsrandom[endpoints(datetimesecondsrandom, Hour(1))]\n6-element Vector{DateTime}:\n 2022-10-08T09:43:57\n 2022-10-08T10:44:34\n 2022-10-08T11:56:46\n 2022-10-08T12:32:08\n 2022-10-08T13:59:08\n 2022-10-08T14:37:17\n\n\n\n\n\n","category":"function"},{"location":"api/#TSFrames.head","page":"API reference","title":"TSFrames.head","text":"Head\n\nhead(ts::TSFrame, n::Int = 10)\n\nReturns the first n rows of ts.\n\nExamples\n\njulia> head(TSFrame(1:100))\n(10 x 1) TSFrame with Int64 Index\n\n Index  x1\n Int64  Int64\n──────────────\n     1      1\n     2      2\n     3      3\n     4      4\n     5      5\n     6      6\n     7      7\n     8      8\n     9      9\n    10     10\n\n\n\n\n\n","category":"function"},{"location":"api/#TSFrames.index-Tuple{TSFrame}","page":"API reference","title":"TSFrames.index","text":"Index column\n\nindex(ts::TSFrame)\n\nReturn the index vector from the coredata DataFrame.\n\nExamples\n\njulia> using Random;\n\njulia> random(x) = rand(MersenneTwister(123), x);\n\njulia> ts = TSFrame(random(10), Date(\"2022-02-01\"):Month(1):Date(\"2022-02-01\")+Month(9));\n\n\njulia> show(ts)\n(10 x 1) TSFrame with Dates.Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2022-02-01  0.768448\n 2022-03-01  0.940515\n 2022-04-01  0.673959\n 2022-05-01  0.395453\n 2022-06-01  0.313244\n 2022-07-01  0.662555\n 2022-08-01  0.586022\n 2022-09-01  0.0521332\n 2022-10-01  0.26864\n 2022-11-01  0.108871\n\njulia> index(ts)\n10-element Vector{Date}:\n 2022-02-01\n 2022-03-01\n 2022-04-01\n 2022-05-01\n 2022-06-01\n 2022-07-01\n 2022-08-01\n 2022-09-01\n 2022-10-01\n 2022-11-01\n\njulia>  eltype(index(ts))\nDate\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.lag","page":"API reference","title":"TSFrames.lag","text":"Lagging\n\nlag(ts::TSFrame, lag_value::Int = 1)\n\nLag the ts object by the specified lag_value. The rows corresponding to lagged values will be rendered as missing. Negative values of lag are also accepted (see TSFrames.lead).\n\nExamples\n\njulia> using Random, Statistics;\n\njulia> random(x) = rand(MersenneTwister(123), x);\n\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2017,1,10));\n\njulia> ts = TSFrame(random(length(dates)), dates);\njulia> show(ts)\n(10 x 1) TSFrame with Dates.Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n 2017-01-09  0.26864\n 2017-01-10  0.108871\n\n\njulia> lag(ts)\n(10 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64?\n─────────────────────────────\n 2017-01-01  missing\n 2017-01-02        0.768448\n 2017-01-03        0.940515\n 2017-01-04        0.673959\n 2017-01-05        0.395453\n 2017-01-06        0.313244\n 2017-01-07        0.662555\n 2017-01-08        0.586022\n 2017-01-09        0.0521332\n 2017-01-10        0.26864\n\njulia> lag(ts, 2) # lags by 2 values\n(10 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64?\n─────────────────────────────\n 2017-01-01  missing\n 2017-01-02  missing\n 2017-01-03        0.768448\n 2017-01-04        0.940515\n 2017-01-05        0.673959\n 2017-01-06        0.395453\n 2017-01-07        0.313244\n 2017-01-08        0.662555\n 2017-01-09        0.586022\n 2017-01-10        0.0521332\n\n\n\n\n\n\n","category":"function"},{"location":"api/#TSFrames.lead","page":"API reference","title":"TSFrames.lead","text":"Leading\n\nlead(ts::TSFrame, lead_value::Int = 1)\n\nSimilar to lag, this method leads the ts object by lead_value. The lead rows are inserted with missing. Negative values of lead are also accepted (see TSFrames.lag).\n\nExamples\n\njulia> using Random, Statistics;\n\njulia> random(x) = rand(MersenneTwister(123), x);\n\njulia> dates = collect(Date(2017,1,1):Day(1):Date(2018,3,10));\n\njulia> ts = TSFrame(DataFrame(Index = dates, x1 = random(length(dates))))\njulia> show(ts)\n(434 x 1) TSFrame with Dates.Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2017-01-01  0.768448\n 2017-01-02  0.940515\n 2017-01-03  0.673959\n 2017-01-04  0.395453\n 2017-01-05  0.313244\n 2017-01-06  0.662555\n 2017-01-07  0.586022\n 2017-01-08  0.0521332\n     ⋮           ⋮\n 2018-03-03  0.127635\n 2018-03-04  0.147813\n 2018-03-05  0.873555\n 2018-03-06  0.486486\n 2018-03-07  0.495525\n 2018-03-08  0.64075\n 2018-03-09  0.375126\n 2018-03-10  0.0338698\n       418 rows omitted\n\n\njulia> lead(ts)[1:10]        # leads once\n(10 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64?\n───────────────────────\n 2017-01-01  0.940515\n 2017-01-02  0.673959\n 2017-01-03  0.395453\n 2017-01-04  0.313244\n 2017-01-05  0.662555\n 2017-01-06  0.586022\n 2017-01-07  0.0521332\n 2017-01-08  0.26864\n 2017-01-09  0.108871\n 2017-01-10  0.163666\n\njulia> lead(ts, 2)[1:10]     # leads by 2 values\n(10 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64?\n───────────────────────\n 2017-01-01  0.673959\n 2017-01-02  0.395453\n 2017-01-03  0.313244\n 2017-01-04  0.662555\n 2017-01-05  0.586022\n 2017-01-06  0.0521332\n 2017-01-07  0.26864\n 2017-01-08  0.108871\n 2017-01-09  0.163666\n 2017-01-10  0.473017\n\n\n\n\n\n\n","category":"function"},{"location":"api/#TSFrames.ncol-Tuple{TSFrame}","page":"API reference","title":"TSFrames.ncol","text":"Size methods\n\nncol(ts::TSFrame)\n\nReturn the number of columns of ts. nc is an alias for ncol.\n\nExamples\n\njulia> using Random;\n\njulia> random(x) = rand(MersenneTwister(123), x);\n\njulia> TSFrames.ncol(TSFrame([random(100) random(100) random(100)]))\n3\n\njulia> nc(TSFrame([random(100) random(100) random(100)]))\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.nrow-Tuple{TSFrame}","page":"API reference","title":"TSFrames.nrow","text":"Size methods\n\nnrow(ts::TSFrame)\nnr(ts::TSFrame)\n\nReturn the number of rows of ts. nr is an alias for nrow.\n\nExamples\n\njulia> ts = TSFrame(collect(1:10))\njulia> TSFrames.nrow(ts)\n10\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.rename!-Tuple{TSFrame, AbstractVector{String}}","page":"API reference","title":"TSFrames.rename!","text":"Column Rename\n\nrename!(ts::TSFrame, colnames::AbstractVector{String})\nrename!(ts::TSFrame, colnames::AbstractVector{Symbol})\n\nRenames columns of ts to the values in colnames, in order. Input is a vector of either Strings or Symbols. The Index column name is reserved, and rename!() will throw an error if colnames contains the name Index.\n\njulia> ts\n(100 x 2) TSFrame with Int64 Index\n\n Index  x1     x2\n Int64  Int64  Int64\n─────────────────────\n     1      2      1\n     2      3      2\n     3      4      3\n     4      5      4\n   ⋮      ⋮      ⋮\n    97     98     97\n    98     99     98\n    99    100     99\n   100    101    100\n      92 rows omitted\n\njulia> rename!(ts, [\"Col1\", \"Col2\"])\n(100 x 2) TSFrame with Int64 Index\n\nIndex  Col1   Col2\nInt64  Int64  Int64\n─────────────────────\n    1      2      1\n    2      3      2\n    3      4      3\n    4      5      4\n  ⋮      ⋮      ⋮\n   97     98     97\n   98     99     98\n   99    100     99\n  100    101    100\n     92 rows omitted\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.rollapply-Tuple{Function, TSFrame, Any, Int64}","page":"API reference","title":"TSFrames.rollapply","text":"Rolling Functions\n\nrollapply(fun::Function, ts::TSFrame, column::Any, windowsize::Int)\n\nApply a function to a column of ts for each continuous set of rows of size windowsize. column could be any of the DataFrame column selectors.\n\nThe output is a TSFrame object with (nrow(ts) - windowsize + 1) rows indexed with the last index value of each window.\n\nThis method uses RollingFunctions package to implement this functionality.\n\nExamples\n\njulia> ts = TSFrame(1:12, Date(\"2022-02-01\"):Month(1):Date(\"2022-02-01\")+Month(11))\n\njulia> show(ts)\n(12 x 1) TSFrame with Dates.Date Index\n\n Index       x1\n Date        Int64\n───────────────────\n 2022-02-01      1\n 2022-03-01      2\n 2022-04-01      3\n 2022-05-01      4\n 2022-06-01      5\n 2022-07-01      6\n 2022-08-01      7\n 2022-09-01      8\n 2022-10-01      9\n 2022-11-01     10\n 2022-12-01     11\n 2023-01-01     12\n\njulia> rollapply(sum, ts, :x1, 10)\n(3 x 1) TSFrame with Dates.Date Index\n\n Index       x1_rolling_sum\n Date        Float64\n────────────────────────────\n 2022-11-01            55.0\n 2022-12-01            65.0\n 2023-01-01            75.0\n\njulia> rollapply(Statistics.mean, ts, 1, 5)\n(8 x 1) TSFrame with Dates.Date Index\n\n Index       x1_rolling_mean\n Date        Float64\n─────────────────────────────\n 2022-06-01              3.0\n 2022-07-01              4.0\n 2022-08-01              5.0\n 2022-09-01              6.0\n 2022-10-01              7.0\n 2022-11-01              8.0\n 2022-12-01              9.0\n 2023-01-01             10.0\n\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.subset-Union{Tuple{T}, Tuple{TSFrame, T, T}} where T<:Union{Int64, Dates.TimeType}","page":"API reference","title":"TSFrames.subset","text":"Subsetting based on Index\n\nsubset(ts::TSFrame, from::T, to::T) where {T<:Union{Int, TimeType}}\n\nCreate a subset of ts based on the Index starting from (inclusive) till to (inclusive).\n\nExamples\n\njulia> using Random;\njulia> random(x) = rand(MersenneTwister(123), x);\njulia> dates = Date(\"2022-02-01\"):Week(1):Date(\"2022-02-01\")+Month(9);\njulia> ts = TSFrame(random(length(dates)), dates)\njulia> show(ts)\n(40 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2022-02-01  0.768448\n 2022-02-08  0.940515\n 2022-02-15  0.673959\n 2022-02-22  0.395453\n 2022-03-01  0.313244\n 2022-03-08  0.662555\n 2022-03-15  0.586022\n 2022-03-22  0.0521332\n 2022-03-29  0.26864\n 2022-04-05  0.108871\n 2022-04-12  0.163666\n 2022-04-19  0.473017\n 2022-04-26  0.865412\n 2022-05-03  0.617492\n 2022-05-10  0.285698\n 2022-05-17  0.463847\n 2022-05-24  0.275819\n 2022-05-31  0.446568\n 2022-06-07  0.582318\n 2022-06-14  0.255981\n 2022-06-21  0.70586\n 2022-06-28  0.291978\n 2022-07-05  0.281066\n 2022-07-12  0.792931\n 2022-07-19  0.20923\n 2022-07-26  0.918165\n 2022-08-02  0.614255\n 2022-08-09  0.802665\n 2022-08-16  0.555668\n 2022-08-23  0.940782\n 2022-08-30  0.48\n 2022-09-06  0.790201\n 2022-09-13  0.356221\n 2022-09-20  0.900925\n 2022-09-27  0.529253\n 2022-10-04  0.031831\n 2022-10-11  0.900681\n 2022-10-18  0.940299\n 2022-10-25  0.621379\n 2022-11-01  0.348173\n\njulia> subset(ts, Date(2022, 03), Date(2022, 07))\n(18 x 1) TSFrame with Date Index\n\n Index       x1\n Date        Float64\n───────────────────────\n 2022-03-01  0.313244\n 2022-03-08  0.662555\n 2022-03-15  0.586022\n 2022-03-22  0.0521332\n 2022-03-29  0.26864\n 2022-04-05  0.108871\n 2022-04-12  0.163666\n 2022-04-19  0.473017\n 2022-04-26  0.865412\n 2022-05-03  0.617492\n 2022-05-10  0.285698\n 2022-05-17  0.463847\n 2022-05-24  0.275819\n 2022-05-31  0.446568\n 2022-06-07  0.582318\n 2022-06-14  0.255981\n 2022-06-21  0.70586\n 2022-06-28  0.291978\n\njulia> subset(TSFrame(1:20, -9:10), -4, 5)\n(10 x 1) TSFrame with Int64 Index\n\n Index  x1\n Int64  Int64\n──────────────\n    -4      6\n    -3      7\n    -2      8\n    -1      9\n     0     10\n     1     11\n     2     12\n     3     13\n     4     14\n     5     15\n\njulia> subset(ts,:,Date(\"2022-04-12\"))\n(11 x 1) TSFrame with Date Index\n\n Index       x1        \n Date        Float64   \n───────────────────────\n 2022-02-01  0.768448\n 2022-02-08  0.940515\n 2022-02-15  0.673959\n 2022-02-22  0.395453\n 2022-03-01  0.313244\n 2022-03-08  0.662555\n 2022-03-15  0.586022\n 2022-03-22  0.0521332\n 2022-03-29  0.26864\n 2022-04-05  0.108871\n 2022-04-12  0.163666\n\njulia> subset(ts,Date(\"2022-9-27\"),:)\n(6 x 1) TSFrame with Date Index\n\n Index       x1       \n Date        Float64  \n──────────────────────\n 2022-09-27  0.529253\n 2022-10-04  0.031831\n 2022-10-11  0.900681\n 2022-10-18  0.940299\n 2022-10-25  0.621379\n 2022-11-01  0.348173\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#TSFrames.tail","page":"API reference","title":"TSFrames.tail","text":"Tail\n\ntail(ts::TSFrame, n::Int = 10)\n\nReturns the last n rows of ts.\n\njulia> tail(TSFrame(1:100))\n(10 x 1) TSFrame with Int64 Index\n\n Index  x1\n Int64  Int64\n──────────────\n    91     91\n    92     92\n    93     93\n    94     94\n    95     95\n    96     96\n    97     97\n    98     98\n    99     99\n   100    100\n\n\n\n\n\n","category":"function"},{"location":"api/#TSFrames.to_period-Union{Tuple{T}, Tuple{TSFrame, T}} where T<:Dates.Period","page":"API reference","title":"TSFrames.to_period","text":"Frequency conversion\n\nSet of convenience methods for frequency conversion of TimeType index types. Internally, they call endpoints() to do the actual conversion. n is the number of periods of the period type. For example, to_monthly(tsf, 2) will resample the time series to \"every 2 months\".\n\nto_period(tsf::TSFrame, period::T)::TSFrame where {T<:Period}\nto_yearly(tsf::TSFrame, n=1)::TSFrame\nto_quarterly(tsf::TSFrame, n=1)::TSFrame\nto_monthly(tsf::TSFrame, n=1)::TSFrame\nto_weekly(tsf::TSFrame, n=1)::TSFrame\nto_daily(tsf::TSFrame, n=1)::TSFrame\nto_hourly(tsf::TSFrame, n=1)::TSFrame\nto_minutes(tsf::TSFrame, n=1)::TSFrame\nto_seconds(tsf::TSFrame, n=1)::TSFrame\nto_milliseconds(tsf::TSFrame, n=1)::TSFrame\nto_microseconds(tsf::TSFrame, n=1)::TSFrame\nto_nanoseconds(tsf::TSFrame, n=1)::TSFrame\n\n\n\n\n\n","category":"method"},{"location":"user_guide/#User-guide","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"This page describes how to use the TSFrames package for timeseries data handling.","category":"page"},{"location":"user_guide/#Installation","page":"User guide","title":"Installation","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/xKDR/TSFrames.jl\")","category":"page"},{"location":"user_guide/#Constructing-TSFrame-objects","page":"User guide","title":"Constructing TSFrame objects","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"After installing TSFrames you need to load the package in Julia environment. Then, create a basic TSFrame object.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"using TSFrames;\nts = TSFrame(1:10)\nts.coredata","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"The basic TSFrame constructor takes in a Vector of any type and automatically generates an index out of it (the Index column).","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"There are many ways to construct a TSFrame object. For real world applications you would want to read in a CSV file or download a dataset as a DataFrame and then operate on it. You can easily convert a DataFrame to a TSFrame object.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"using CSV, DataFrames, TSFrames, Dates\ndates = Date(2007, 1, 1):Day(1):Date(2008, 03, 06)\nts = TSFrame(DataFrame(Index=dates, value=10*rand(431)))","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"In the above example you generate a random DataFrame and convert it into a TSFrame object ts. The top line of the ts object tells you the number of rows (431 here) and the number of columns (1) along with the Type of Index (Dates.Date in the above example).","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"You can also fetch the number of rows and columns by using nr(ts), nc(ts), and size(ts) methods. Respectively, they fetch the number of rows, columns, and a Tuple of row and column numbers. A length(::TSFrame) method is also provided for convenience which returns the number of rows of it's argument.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"nr(ts)\nnc(ts)\nsize(ts)\nlength(ts)","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Names of data columns can be fetched using the names(ts) method which returns a Vector{String} object. The Index column can be fetched as an object of Vector type by using the index(ts) method, it can also be fetched directly using the underlying coredata property of TSFrame: ts.coredata[!, :Index].","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"names(ts)\nindex(ts)","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Another simpler way to read a CSV is to pass TSFrame as a sink to the CSV.read function.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"julia> ts = CSV.File(filename, TSFrame)","category":"page"},{"location":"user_guide/#Indexing-and-subsetting","page":"User guide","title":"Indexing and subsetting","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"One of the primary features of a timeseries package is to provide ways to index or subset a dataset using convenient interfaces. TSFrames makes it easier to index a TSFrame object by providing multiple intuitive getindex methods which work by just using the regular square parentheses([ ]).","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"ts[1] # first row\nts[[3, 5], [1]] # third & fifth row, and first column\nts[1:10, 1] # first 10 rows and the first column as a vector\nts[1, [:value]] # using the column name","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Apart from integer-based row indexing and integer, name based column indexing, TSFrames provides special subsetting methods for date and time types defined inside the Dates module.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"ts[Date(2007, 1, 10)] # on January 10, 2007\nts[[Date(2007, 1, 10), Date(2007, 1, 11)]] # January 10, 11\nts[Year(2007), Month(1)] # entire January 2007\nts[Year(2007), Quarter(2)]","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Finally, one can also use the dot notation to get a column as a vector.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"ts.value # get the value column as a vector","category":"page"},{"location":"user_guide/#Summary-statistics","page":"User guide","title":"Summary statistics","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"The describe() method prints summary statistics of the TSFrame object. The output is a DataFrame which includes the number of missing values, data types of columns along with computed statistical values.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"TSFrames.describe(ts)","category":"page"},{"location":"user_guide/#Plotting","page":"User guide","title":"Plotting","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"A TSFrame object can be plotted using the plot() function of the Plots package. The plotting functionality is provided by RecipesBase package so all the flexibility and functionality of the Plots package is available for users.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"using Plots\nplot(ts, size=(600,400); legend=false)","category":"page"},{"location":"user_guide/#Applying-a-function-over-a-period","page":"User guide","title":"Applying a function over a period","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"The apply method allows you to aggregate the TSFrame object over a period type (Dates.Period(@ref)) and return the output of applying the function on each period. For example, to convert frequency of daily timeseries to monthly you may use first(), last(), or Statistics.mean() functions and the period as Dates.Month.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"using Statistics\nts_monthly = apply(ts, Month(1), last) # convert to monthly series using the last value for each month\nts_weekly = apply(ts, Week(1), Statistics.std) # compute weekly standard deviation\napply(ts, Week(1), Statistics.std, last) # same as above but index contains the last date of the week\napply(ts, Week(1), Statistics.std, last, renamecols=false) # do not rename column","category":"page"},{"location":"user_guide/#Joins:-Row-and-column-binding-with-other-objects","page":"User guide","title":"Joins: Row and column binding with other objects","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"TSFrames provides methods to join two TSFrame objects by columns: join (alias: cbind) or by rows: vcat (alias: rbind). Both the methods provide some basic intelligence while doing the merge.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"join merges two datasets based on the Index values of both objects. Depending on the join strategy employed the final object may only contain index values only from the left object (using jointype=:JoinLeft), the right object (using jointype=:JoinRight), intersection of both objects (using jointype=:JoinBoth), or a union of both objects (jointype=:JoinAll) while inserting missing values where index values are missing from any of the other object.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"dates = collect(Date(2007,1,1):Day(1):Date(2007,1,30));\nts2 = TSFrame(rand(length(dates)), dates)\njoin(ts, ts2; jointype=:JoinAll) # cbind/join on Index column","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"vcat also works similarly but merges two datasets by rows. This method also uses certain strategies provided via colmerge argument to check for certain conditions before doing the merge, throwing an error if the conditions are not satisfied.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"colmerge can be passed setequal which merges only if both objects have same column names, orderequal which merges only if both objects have same column names and columns are in the same order, intersect merges only the columns which are common to both objects, and union which merges even if the columns differ between the two objects, the resulting object has the columns filled with missing, if necessary.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"For vcat, if the values of Index are same in the two objects then all the index values along with values in other columns are kept in the resulting object. So, a vcat operation may result in duplicate Index values and the results from other operations may differ or even throw unknown errors.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"dates = collect(Date(2008,4,1):Day(1):Date(2008,4,30));\nts3 = TSFrame(DataFrame(values=rand(length(dates)), Index=dates))\nvcat(ts, ts3) # do the merge","category":"page"},{"location":"user_guide/#Rolling-window-operations","page":"User guide","title":"Rolling window operations","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"The rollapply applies a function over a fixed-size rolling window on the dataset. In the example below, we compute the 10-day average of dataset values on a rolling basis.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"rollapply(Statistics.mean, ts, :value, 10)","category":"page"},{"location":"user_guide/#Computing-rolling-difference-and-percent-change","page":"User guide","title":"Computing rolling difference and percent change","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Similar to apply and rollapply there are specific methods to compute rolling differences and percent changes of a TSFrame object. The diff method computes mathematical difference of values in adjacent rows, inserting missing in the first row. pctchange computes the percentage change between adjacent rows.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"diff(ts)\npctchange(ts)","category":"page"},{"location":"user_guide/#Computing-log-of-data-values","page":"User guide","title":"Computing log of data values","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"log.(ts)","category":"page"},{"location":"user_guide/#Creating-lagged/leading-series","page":"User guide","title":"Creating lagged/leading series","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"lag() and lead() provide ways to lag or lead a series respectively by a fixed value, inserting missing where required.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"lag(ts, 2)\nlead(ts, 2)","category":"page"},{"location":"user_guide/#Converting-to-Matrix-and-DataFrame","page":"User guide","title":"Converting to Matrix and DataFrame","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"You can easily convert a TSFrame object into a Matrix or fetch the DataFrame for doing operations which are outside of the TSFrames scope.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"ts[:, 1] # convert column 1 to a vector of floats\nMatrix(ts) # convert entire TSFrame into a Matrix\nselect(ts.coredata, :Index, :value, DataFrames.nrow) # use the underlying DataFrame for other operations","category":"page"},{"location":"user_guide/#Writing-TSFrame-into-a-CSV-file","page":"User guide","title":"Writing TSFrame into a CSV file","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Writing a TSFrame object into a CSV file can be done easily by using the underlying coredata property. This DataFrame can be passed to the CSV.write method for writing into a file.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"CSV.write(\"/tmp/demo_ts.csv\", ts)","category":"page"},{"location":"user_guide/#Broadcasting","page":"User guide","title":"Broadcasting","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Broadcasting can be used on a TSFrame object to apply a function to a subset of it's columns.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"julia> using TSFrames, DataFrames;\n\njulia> ts = TSFrame(DataFrame(Index = [1, 2, 3, 4, 5], A = [10.1, 12.4, 42.4, 24.1, 242.5], B = [2, 4, 6, 8, 10]))\n(5 x 2) TSFrame with Int64 Index\n\n Index  A        B     \n Int64  Float64  Int64 \n───────────────────────\n     1     10.1      2\n     2     12.4      4\n     3     42.4      6\n     4     24.1      8\n     5    242.5     10\n\njulia> sin_A = sin.(ts[:, [:A]])    # get sin of column A\n(5 x 1) TSFrame with Int64 Index\n\n Index  A_sin\n Int64  Float64\n──────────────────\n     1  -0.625071\n     2  -0.165604\n     3  -0.999934\n     4  -0.858707\n     5  -0.562466\n\njulia> log_ts = log.(ts)    # take log of all columns\n(5 x 2) TSFrame with Int64 Index\n\n Index  A_log    B_log\n Int64  Float64  Float64\n──────────────────────────\n     1  2.31254  0.693147\n     2  2.5177   1.38629\n     3  3.74715  1.79176\n     4  3.18221  2.07944\n     5  5.491    2.30259\n\njulia> log_ts = log.(ts[:, [:A, :B]])   # can specify multiple columns\n(5 x 2) TSFrame with Int64 Index\n\n Index  A_log    B_log\n Int64  Float64  Float64\n──────────────────────────\n     1  2.31254  0.693147\n     2  2.5177   1.38629\n     3  3.74715  1.79176\n     4  3.18221  2.07944\n     5  5.491    2.30259\n","category":"page"},{"location":"user_guide/#[Tables.jl](https://github.com/JuliaData/Tables.jl)-Integration","page":"User guide","title":"Tables.jl Integration","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"TSFrame objects are Tables.jl compatible. This integration enables easy conversion between the TSFrame format and other formats which are Tables.jl compatible.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"As an example, first consider the following code which converts a TSFrame object into a DataFrame, a TimeArray and a CSV file respectively.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"julia> using TSFrames, TimeSeries, Dates, DataFrames, CSV;\n\njulia> dates = Date(2018, 1, 1):Day(1):Date(2018, 12, 31)\nDate(\"2018-01-01\"):Day(1):Date(\"2018-12-31\")\n\njulia> ts = TSFrame(DataFrame(Index = dates, x1 = 1:365));\n\n# conversion to DataFrames\njulia> df = DataFrame(ts);\n\n# conversion to TimeArray\njulia> timeArray = TimeArray(ts, timestamp = :Index);\n\n# writing to CSV\njulia> CSV.write(\"ts.csv\", ts);\n","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Next, here is some code which converts a DataFrame, a TimeArray and a CSV file to a TSFrame object.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"julia> using TSFrames, DataFrames, CSV, TimeSeries, Dates;\n\n# converting DataFrame to TSFrame\njulia> ts = TSFrame(DataFrame(Index=1:10, x1=1:10));\n\n# converting from TimeArray to TSFrame\njulia> dates = Date(2018, 1, 1):Day(1):Date(2018, 12, 31)\nDate(\"2018-01-01\"):Day(1):Date(\"2018-12-31\")\n\njulia> ta = TimeArray(dates, rand(length(dates)));\n\njulia> ts = TSFrame(ta);\n\n# converting from CSV to TSFrame\njulia> CSV.read(\"ts.csv\", TSFrame);","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"note: Note\nThis discussion warrants a note about how we've implemented the Tables.jl interfaces. Since TSFrame objects are nothing but a wrapper around a DataFrame, our implementations of these interfaces just call DataFrames.jl's implementations. Moreover, while constructing TSFrame objects out of other Tables.jl compatible types, our constructor first converts the input table to a DataFrame, and then converts the DataFrame to a TSFrame object.","category":"page"},{"location":"demo_finance/#Basic-demo-of-TSFrames-using-financial-data","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames using financial data","text":"","category":"section"},{"location":"demo_finance/#Create-a-TSFrame-object-for-IBM-historical-data","page":"Basic demo of TSFrames","title":"Create a TSFrame object for IBM historical data","text":"","category":"section"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"To load the IBM historical data, we will use the MarketData.yahoo function from MarketData.jl, which returns the data in the form of a TimeArray. We just simply pass this on to the TSFrame constructor.","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"using TSFrames, MarketData, Plots, Statistics\nibm_ts = TSFrame(MarketData.yahoo(:IBM))","category":"page"},{"location":"demo_finance/#Create-TSFrame-object-for-AAPL","page":"Basic demo of TSFrames","title":"Create TSFrame object for AAPL","text":"","category":"section"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"Similarly, we can create a TSFrame object for the AAPL data.","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"aapl_ts = TSFrame(MarketData.yahoo(:AAPL))","category":"page"},{"location":"demo_finance/#Create-a-6-month-subset-of-stock-data","page":"Basic demo of TSFrames","title":"Create a 6-month subset of stock data","text":"","category":"section"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"We would like to compare the stock returns for both the stocks for 6 months starting from June 1, 2021 till December 31, 2021. We use TSFrames.subset method to create new objects which contain the specified duration of data.","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"date_from = Date(2021, 06, 01);\ndate_to = Date(2021, 12, 31);\n\nibm = TSFrames.subset(ibm_ts, date_from, date_to)","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"aapl = TSFrames.subset(aapl_ts, date_from, date_to)","category":"page"},{"location":"demo_finance/#Combine-adjusted-closing-prices-of-both-stocks-into-one-object","page":"Basic demo of TSFrames","title":"Combine adjusted closing prices of both stocks into one object","text":"","category":"section"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"We now join (cbind) both the stocks' data into a single object for further analysis. We use TSFrames.join to create two columns containing adjusted closing prices of both the stocks. The join happens by comparing the Index values (dates) of the two objects. The resulting object contains two columns with exactly the same dates for which both the objects have data, all the other rows are omitted from the result.","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"ibm_aapl = TSFrames.join(ibm[:, [\"AdjClose\"]], aapl[:, [\"AdjClose\"]]; jointype=:JoinBoth)\nTSFrames.rename!(ibm_aapl, [:IBM, :AAPL])","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"After the join operation the column names are modified because we merged two same-named columns (AdjClose) so we use TSFrames.rename!() method to rename the columns to easily remembered stock names.","category":"page"},{"location":"demo_finance/#Convert-data-into-weekly-frequency-using-last-values","page":"Basic demo of TSFrames","title":"Convert data into weekly frequency using last values","text":"","category":"section"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"Here, we convert daily stock data into weekly frequency by taking the value with which the trading closed on the last day of the week as the week's price.","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"ibm_aapl_weekly = to_weekly(ibm_aapl)","category":"page"},{"location":"demo_finance/#Compute-weekly-returns-using-the-familiar-log-and-diff-functions","page":"Basic demo of TSFrames","title":"Compute weekly returns using the familiar log and diff functions","text":"","category":"section"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"ibm_aapl_weekly_returns = diff(log.(ibm_aapl_weekly))\nTSFrames.rename!(ibm_aapl_weekly_returns, [:IBM, :AAPL])","category":"page"},{"location":"demo_finance/#Compute-standard-deviation-of-weekly-returns","page":"Basic demo of TSFrames","title":"Compute standard deviation of weekly returns","text":"","category":"section"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"Computing standard deviation is done using the std function from Statistics package. The skipmissing is used to skip missing values which may have been generated while computing log returns or were already present in the data.","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"ibm_std = std(skipmissing(ibm_aapl_weekly_returns[:, :IBM]))","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"aapl_std = std(skipmissing(ibm_aapl_weekly_returns[:, :AAPL]))","category":"page"},{"location":"demo_finance/#Scatter-plot-of-AAPL-and-IBM","page":"Basic demo of TSFrames","title":"Scatter plot of AAPL and IBM","text":"","category":"section"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"Here, we use the Plots package to create a scatter plot with IBM weekly returns on the x-axis and Apple weekly returns on the y-axis.","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nplot(ibm_aapl_weekly_returns[:, :AAPL],\n    ibm_aapl_weekly_returns[:, :IBM],\n    seriestype = :scatter;\n    xlabel = \"AAPL\",\n    ylabel = \"IBM\",\n    legend = false)\nsavefig(\"ts-plot.svg\"); nothing # hide","category":"page"},{"location":"demo_finance/","page":"Basic demo of TSFrames","title":"Basic demo of TSFrames","text":"(Image: )","category":"page"},{"location":"#TSFrames.jl","page":"Introduction","title":"TSFrames.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TSFrames provides a convenient interface for performing standard manipulations of timeseries data. The package uses DataFrame at it's core to allow powerful data manipulation functions while being lightweight. It is inspired by zoo and xts packages from the R world.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TSFrames wraps a familiar syntax for timeseries operations over DataFrame type, thereby, providing the user with full set of DataFrame functionalities as well. Integrations with other packages in the Julia ecosystem which are supported by DataFrames.jl come to TSFrames at little cost.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To start using TSFrames.jl take a look at the basic demo and then head to the User guide.","category":"page"},{"location":"#User-guide","page":"Introduction","title":"User guide","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"user_guide.md\"]","category":"page"},{"location":"#API-reference","page":"Introduction","title":"API reference","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"api.md\"]","category":"page"}]
}
